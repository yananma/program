
int num1 = 10
cout << num1 << endl; 结果是 10

& 是取址运算符，得到变量所在的地址，用法是 & 变量名称，比如 &num1 是地址

cout << &num1 << endl; 结果是 0x6ffe30

指针变量就是用来存储内存地址的变量，和 &变量名称 完全等价，就是不用多写一个符号了

p = & num1，p 指针存的也是地址

* 是取值运算符

\*p 就是取指针指向空间的内容

\*p=20，就是重新赋值



#### 基本语法  

所有的 C 语言程序都需要包含 main() 函数。 代码从 main() 函数开始执行。  

/\* ... \*/ 用于注释说明。  

C 语言最初是用于系统开发工作，特别是组成操作系统的程序。  

由于 C 语言所产生的代码运行速度与汇编语言编写的代码运行速度几乎一样。  

return 0; 终止 main() 函数，并返回值 0。  


C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。  

register 声明寄存器变量  

sizeof 计算数据类型或变量长度（即所占字节数）  

static 声明静态变量  

void 声明函数无返回值或无参数，声明无类型指针。    

变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，变量的类型决定了变量存储占用的空间和布局，以及如何解释存储的位模式。该范围内的值都可以存储在内存中，运算符可应用于变量上。  

变量定义模式：`type variable_list;`，比如 `int  i, j, k;`、`char ch;`  

变量可以在声明的时候被初始化（指定一个初始值）：`type variable_name = value;`，比如 `int d = 3, f = 5;`、`byte z = 22;`  

常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。  

请注意，把常量定义为大写字母形式，是一个很好的编程习惯。  


#### 存储类  

存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。  

register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。  

寄存器只用于需要快速访问的变量，比如计数器。  

static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。  

比如调用的时候，值是 5，然后变量加 1，出了函数，再次调用的时候，值就是 6 了，而不会重新赋值成 5.  

static 修饰符也可以应用于全局变量。  


#### 运算符  

||	称为逻辑或运算符，一个满足就为真  

? : 运算符(三元运算符)。? : 可以用来替代 if...else 语句。  

Exp1 ? Exp2 : Exp3; ? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个表达式的值。  

循环：需要多次执行同一块代码。  

#### 函数  

C 语言中的函数定义的一般形式如下：
```c
return_type function_name( parameter list )
{
   body of the function
}
```

return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。  

函数名称：函数的实际名称。  

创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。  

当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。  

创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。  

当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。  

传值调用：该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。  

引用调用：通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。  

默认情况下，C 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。  

#### 作用域规则 

任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：
1. 在函数或块内部的局部变量  
在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。  

2. 在所有函数外部的全局变量
全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。  
全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。  
在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。  

3. 在形式参数的函数参数定义中的形式参数  
函数的参数，形式参数，被当作该函数内的局部变量。  

全局变量与局部变量在内存中的区别：  
全局变量保存在内存的全局存储区中，占用静态的存储单元；  
局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。  


#### 数组

C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。  

数组中的特定元素可以通过索引访问，第一个索引值为 0。  

声明数组  
在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：
`type arrayName [ arraySize ];`  

这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 balance，声明语句如下：
`double balance[10];`  

访问数组元素  
数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：  
`double salary = balance[9];`  

enum(枚举)  
枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。  

枚举语法定义格式为：  
enum　枚举名　{枚举元素1,枚举元素2,……};  

#### 指针

学习 C 语言的指针既简单又有趣。通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C 程序员，学习指针是很有必要的。  

每一个变量都有一个内存位置，每一个内存位置都定义了可使用 & 运算符访问的地址，它表示了在内存中的一个地址。  

```c 
#include <stdio.h>
 
int main ()
{
    int var_runoob = 10;
    int *p;              // 定义指针变量
    p = &var_runoob;
 
   printf("var_runoob 变量的地址： %p\n", p);
   return 0;
}
```
当上面的代码被编译和执行时，它会产生下列结果：  
var_runoob 变量的地址： 0x7ffeeaae08d8  

指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：  
type \*var-name;    

type 是指针的基类型，它必须是一个有效的 C 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：  
```c
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */
```

使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。    
```c
include <stdio.h>
 
int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
 
   ip = &var;  /* 在指针变量中存储 var 的地址 */
 
   printf("var 变量的地址: %p\n", &var  );
 
   /* 在指针变量中存储的地址 */
   printf("ip 变量存储的地址: %p\n", ip );
 
   /* 使用指针访问值 */
   printf("*ip 变量的值: %d\n", *ip );
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

var 变量的地址: 0x7ffeeef168d8  
ip 变量存储的地址: 0x7ffeeef168d8  
\*ip 变量的值: 20    

**ip 是指针变量，\*ip 是指针所指的内容**   

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。  

NULL 指针是一个定义在标准库中的值为零的常量。   


#### 函数指针  

函数指针是指向函数的指针变量。  

通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。  

函数指针可以像一般函数一样，用于调用函数、传递参数。  

`typedef int (*fun_ptr)(int,int);` // 声明一个指向同样参数、返回值的函数指针类型    

以下实例声明了函数指针变量 p，指向函数 max：
```c
#include <stdio.h>
 
int max(int x, int y)
{
    return x > y ? x : y;
}
 
int main(void)
{
    /* p 是函数指针 */
    int (* p)(int, int) = & max; // &可以省略
    int a, b, c, d;
 
    printf("请输入三个数字:");
    scanf("%d %d %d", & a, & b, & c);
 
    /* 与直接调用函数等价，d = max(max(a, b), c) */
    d = p(p(a, b), c);    # 这里是调用函数  
 
    printf("最大的数字是: %d\n", d);
 
    return 0;
}
```

#### 回调函数

函数指针作为某个函数的参数  

函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。  

简单讲：回调函数是由别人的函数执行时调用你实现的函数。  

你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。  


#### 结构体

C 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。   

为了定义结构，必须使用 struct 语句。  
```c
struct tag { 
    member-list
    member-list 
    member-list  
    ...
} variable-list ;
```

tag 是结构体标签。  

member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。  

variable-list 结构变量，定义在结构的末尾，最后一个分号之前。  

结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。  

和其它类型变量一样，对结构体变量可以在定义时指定初始值。  
```c
#include <stdio.h>
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book = {"C 语言", "RUNOOB", "编程语言", 123456};
 
int main()
{
    printf("title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n", book.title, book.author, book.subject, book.book_id);
}
```

可以定义指向结构的指针  


#### typedef 

C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE：

`typedef unsigned char BYTE;`  

在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如：  
`BYTE  b1, b2;`  

#define 是 C 指令，用于为各种数据类型定义别名  


#### 预处理器  

C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。  

所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。  

#define	定义宏  
#include	包含一个源代码文件  
#ifdef	如果宏已经定义，则返回真  
#ifndef	如果宏没有定义，则返回真  
#if	如果给定条件为真，则编译下面代码  


实例  
#define MAX_ARRAY_LENGTH 20  
这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 替换为 20。   
```c
#ifndef MESSAGE
   #define MESSAGE "You wish!"
#endif
```

这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。  

宏延续运算符（\）
一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：
```c
#define  message_for(a, b)  \
    printf(#a " and " #b ": We love you!\n")  
```

#### 强制类型转换  

强制类型转换是把变量从一种类型转换为另一种数据类型。  

`(type_name) expression`  

 `mean = (double) sum / count;`  
 
 
 #### 内存管理  
 
 C 语言为内存的分配和管理提供了几个函数。  

`void *calloc(int num, int size);`   
在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num\*size 个字节长度的内存空间，并且每个字节的值都是0。  

`void free(void *address);`  
该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。  

`void *malloc(int num);`  
在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。  

void * 类型表示未确定类型的指针。void * 类型可以通过类型转换强制转换为任何其它类型的指针。  

编程时，如果预先知道数组的大小，那么定义数组时就比较容易。例如，一个存储人名的数组，它最多容纳 100 个字符，所以可以定义数组，如下所示：
`char name[100];`  

但是，如果预先不知道需要存储的文本长度，例如想存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存。  

```c
/* 动态分配内存 */
   description = (char *)malloc( 200 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   }
   else
   {
      strcpy( description, "Zara ali a DPS student in class 10th");
   }
```
   
当动态分配内存时，我们有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。  
   

在不需要内存时，都应该调用函数 free() 来释放内存。  



